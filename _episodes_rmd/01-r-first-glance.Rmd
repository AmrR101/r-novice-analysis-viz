---
title: "A brief introduction to R"
teaching: 45
exercises: 0
questions:
- "What is R and when should I use it?"
- "How do I use the RStudio graphical user interface?"
- "How do I assign variables?"
- "How do I read tabular data into R?"
- "What is a data frame?"
- "How do I access subsets of a data frame?"
- "How do I calculate simple statistics like mean and median?"
- "How can I access documentation?"
- "How do I install a package?"
objectives:
- "Get introduced to R and RStudio."
- "Learn basic R syntax."
- "Read tabular data from a file into R."
- "Assign values to variables."
- "Select individual values and subsections from data."
- "Perform operations on a data frame of data."
- "Be able to install a package from CRAN."
keypoints:
- "R is a strong statistical computing environment"
- "Thousands of packages for R"
- "Use `variable <- value` to assign a value to a variable in order to
  record it in memory."
- "Objects are created on demand whenever a value is assigned to them."
- "Use `read.table` and `write.table` to import / export data."
- "The function `str` describes the data frame."
- "Use `object[x, y]` to select a single element from a data frame."
- "Use `from:to` to specify a sequence that includes the indices from `from` to `to`."
- "All the indexing and slicing that works on data frames also works on vectors."
- "Use `#` to add comments to programs."
- "Use `mean`, `max`, `min` and `sd` to calculate simple statistics."
- "Use split-apply to calculate statistics across the groups in a data frame."
---


```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("01-r-brief-introduction-")
```

## What is R? <!-- 2 -->

R is a statistical computing environment that has become a widely adopted standard for data analysis various fields - notably bioinformatics.

- R is a dialect of the old (commercial) S language
- R is relatively easy to learn to use - tons of built-in functions
  that are just right for data analysis, focused on interactive use
  and often very high-level
- There are thousands of package implementing algorithms, procedures,
  plots - for life science in particular
- R is also a programming language

Consider using R to get access to packages that implement solution to a given problems like

- differential gene expression analysis, gene set enrichment analysis,
- metabolomics data analysis,
- gene clustering,
- access to online databases on gene expression / annotation etc,
- qRT-PCR,
- multivariate statistics, mixed linear models,
- and much much more..

In this one-day course we will learn

- How to use RStudio, the most diverse and mature integrated
  development environment for R
- R's basic syntax
- Re..
- Visualising data using ggplot2

## RStudio - a graphical interface to R <!-- 1 -->

While R can be used directly in the shell, it is much nicer with a graphical interface. RStudio is by far the best one - let's learn how to use it.

* Point to the different panels: Console, Scripts, Environments, Plots.
* Code and workflow are more reproducible if we can document everything that we do.
* Our end goal is not just to "do stuff" but to do it in a way that anyone can
  easily and exactly replicate our workflow and results.
* The best way to achieve this is to write scripts. RStudio provides an
  environment that allows you to do that.

## Interacting with R <!-- 2 -->

There are two main ways of interacting with R: using the console or by using
script files (plain text files that contain your code).

The console window (in RStudio, the bottom left panel) is the place where R is
waiting for you to tell it what to do, and where it will show the results of a
command.  You can type commands directly into the console, but they will be
forgotten when you close the session. It is better to enter the commands in the
script editor, and save the script. This way, you have a complete record of what
you did, you can easily show others how you did it and you can do it again later
on if needed. You can copy-paste into the R console, but the Rstudio script
editor allows you to 'send' the current line or the currently selected text to
the R console using the `Ctrl-Enter` shortcut.

At some point in your analysis you may want to check the content of variable or
the structure of an object, without necessarily keep a record of it in your
script. You can type these commands directly in the console. RStudio provides
the `Ctrl-1` and `Ctrl-2` shortcuts allow you to jump between the script and the
console windows.

If R is ready to accept commands, the R console shows a `>` prompt. If it
receives a command (by typing, copy-pasting or sent from the script editor using
`Ctrl-Enter`), R will try to execute it, and when ready, show the results and
come back with a new `>`-prompt to wait for new commands.

If R is still waiting for you to enter more data because it isn't complete yet,
the console will show a `+` prompt. It means that you haven't finished entering
a complete command. This is because you have not 'closed' a parenthesis or
quotation. If you're in RStudio and this happens, click inside the console
window and press `Esc`; this should help you out of trouble.

## Basic R syntax and loading a package <!-- 7 -->

Just like with python, we can perform simple operations using the R console and assign the output to variables

```{r}
1 + 1
```

`<-` is the assignment operator. It assigns values on the right to objects on
the left. So, after executing `x <- 3`, the value of `x` is `3`. The arrow can
be read as 3 **goes into** `x`.  You can also use `=` for assignments but not in
all contexts so it is good practice to use `<-` for assignments. `=` should only
be used to specify the values of arguments in functions, see below.

> ## Save some keystrokes..
> In RStudio, typing `Alt + -` (push `Alt`, the key next to your space bar at the
> same time as the `-` key) will write ` <- ` in a single keystroke.
{: .callout}

```{r}
foo <- 1 + 1
foo + 1
```

> ## Commenting
>
> We can add comments to our code using the `#` character. It is
> useful to document our code in this way so that others (and us the
> next time we read it) have an easier time following what the code is
> doing.
{: .callout}

We can create some random numbers from the normal distribution and calculate the mean by using two built-in functions

```{r}
randomNumbers <- rnorm(10)
mean(randomNumbers)
```

> > ## Variable Naming Conventions
>
> Historically, R programmers have used a variety of conventions for naming variables. The `.` character
> in R can be a valid part of a variable name; thus the above assignment could have easily been `random.numbers <- rnorm(10)`.
> This is often confusing to R newcomers who have programmed in languages where `.` has a more significant meaning (like in Python).
> There are many 'standards' in use e.g. `random.numbers`, `random_numbers` or `randomNumbers`. Choose what you prefer, but, just as with british or american spelling, the rule is to be consistent!
{: .callout}


> ## All those built-ins..
>
> In contrast to Python, R has many functions available without
> loading any extra packages (2383 to be exact). These are mostly
> functions and becoming proficient with R is a lot about learning how
> these work.
{: .callout}

While plain R already comes with many functions, one almost always wants to make use of code contributed as packages. The concept is very similar to Python but has some important differences. Say we want to use the `readxl` package which allows us to read Excel sheets directly to R. If you by any chance do not have the `readxl` package on your system you have to install it first. This can be done via the menues in RStudio, or by typing:

```{r, eval=FALSE} 
install.packages("readxl")
```

After that, we can load the package by:

```{r}
library(readxl) # equivalent in Python would have been 'from readxl import *'
```

To see what became available we can

```{r, eval=FALSE}
ls('package:readxl') # or read the documentation
help(package='readxl')
```

Sometimes you just want to use one function and do not want to load all functions. Then you can, without loading the package call the functions using the `::` syntax.

```{r}
readxl::readxl_example()
```
## Reading function documentation <!-- 1 -->

All R functions are documented and you can read about them using RStudio documentation pane, or typing `?object`, eg

```{r, eval=FALSE}
?mean
```
## R data types <!-- 2 -->
R has three main data types that we need to know about, the two main ones are `numeric` which is both integers and floats, `character`, and `factor` which is like integer but with a character label attached to number (or `level`). 

```{r}
is.numeric(1)
is.character("foo")
is.factor(factor(c("a", "b", "c", "c")))
```

There are numerous data structures and classes but mainly three we need to care about.

**Vectors** Scalars act like vectors of length 1.
```{r}
foo <- c(1, 2, 3)
foo[2]
bar <- 1
bar[1]
```

> ## Indexing starts at 1!
>
> Unlike python (and indeed most other programming languages) indexing starts at 1. `bar[0]` is however still syntactic correct, it just selects the null-vector from vector `bar` thus always a vector of length 0.
{: .callout}

**Matrices** work like one would expect, values in two dimensions. 

```{r}
(foo <- matrix(c(1, 2, 3, 4, 5, 6), nrow=2))
```

**Lists** are widely used and work like vectors except that each element can be any data structure - so you can have lists of matrices, lists of lists etc.

```{r}
(foo <- list(bar=c(1, 2, 3), baz=matrix(c(1, 2, 3, 4, 5, 6), nrow=2)))
foo[[2]]
foo[2]
foo$baz
```

Finally, **data frames** but they are so important they deserve a small section on their own.

For a rough comparison: 

- R vectors are like lists (`[]`) in Python 
- R lists are like dicts (`{}`) in Python
- R data frames are very much like `pandas.DataFrame` in Python

## Read data into R <!-- 7 -->

Now that we know how to assign things to variables and use functions, let's read some yeast OD growth data into R using `read.table` and briefly examine the dataset.
 

```{r}
growth <- read.table(file = "data/yeast-growth.csv", header = TRUE, sep = ",")
```

> ## Loading Data Without Headers
>
> What happens if you put `header = FALSE`? The default value is `header = TRUE`?. What do you expect will happen if you leave the default value? Before you run any code, think about what will happen to the first few rows of your data frame, and its overall size. Then run the following code and see if your expectations agree:
>
> ~~~
> head(read.table(file = "data/yeast-growth.csv", header = FALSE, sep = ","))
> ~~~
> {: .r}
{: .challenge}


> ## Where is that file? Or, what is my working directory?
>
> R is always running inside a specific directory, the *working
> directory*. Paths can be given relative to that directory so with
> `data/yeast-growth.csv` we mean 'the file `yeast-growth.csv` in the
> `data` directory that is right at the working directory. Set the
> working directory using RStudio `Session` > `Set Working Directory..` or `setwd()`
{: .callout}


> ## Reading Files from Different 'Locales'
>
> Depending on what countrys standard your computer is set to (the 'locale'), software such as Excel will use different characters to separate fields. E.g., the default for a computer with UK defaults will be to use ';' to separate fields and ',' to separate thousands. Try finding the right arguments to `read.table` to get something sensible out of `data/example-us.txt` and `data/example-dk.txt`.
>
> > ## Solution
> > ~~
> > read.table('data/example-uk.txt', sep=',', header=TRUE)
> > read.table('data/example-dk.txt', sep=';', dec=',', header=TRUE)
> > ~~
{: .challenge}

Reading excel files is not natively supported in R so we need to use a special package for that, `readxl` is recommended.

```{r}
library(readxl)
read_xlsx('data/example-dk.xlsx')
```

## Working with data frames <!-- 10 -->

Now that our data is loaded in memory, we can start doing things with it.
First, let's ask what type of thing `growth` is:

```{r}
head(growth)
str(growth) # what data types are the different columns?
class(growth)
```

The output tells us that is a data frame. Think of this structure as a spreadsheet in MS Excel that many of us are familiar with.
Data frames are very useful for storing data and you will find them elsewhere when programming in R. A typical data frame of experimental data contains individual observations in rows and variables in columns.

We can see the shape, or [dimensions]({{ site.github.url }}/reference/#dimensions), of the data frame with the function `dim`:

```{r}
dim(growth)
```

This tells us that our data frame, `growth`, has `r nrow(growth)` rows and `r ncol(growth)` columns.

If we want to get a single value from the data frame, we can provide an [index]({{ site.github.url }}/reference/#index) in square brackets, just as we do in math:

```{r}
 # first value in dat
growth[1, 1]
 # middle value in dat
growth[30, 2]
```

An index like `[30, 2]` selects a single element of a data frame, but we can select whole sections as well.
For example, we can select the first ten days (columns) of values for the first four patients (rows) like this:

```{r}
growth[1:4, 1:2]
```

We can use the function `c`, which stands for **c**oncatenate, to select non-contiguous values:

```{r}
growth[c(3, 8, 37, 56), c(1, 3)]
```

We also don't have to provide a subset for either the rows or the columns.
If we don't include a subset for the rows, R returns all the rows; if we don't include a subset for the columns, R returns all the columns.
If we don't provide a subset for either rows or columns, e.g. `growth[, ]`, R returns the full data frame.

```{r}
growth[5, ]
```

> ## Addressing Columns by Name (the better way)
>
> Columns can also be addressed by name, with either the `$` operator (ie. `growth$medium`) or square brackets (ie. `growth[,"medium"]`).
> You can learn more about subsetting by column name in this supplementary [lesson]({{ site.github.url }}/10-supp-addressing-data/).
{: .callout}

Particularly useful is also to user other vectors as filters and only return the rows that evaluate to `TRUE`. Here, `growth$well == "a"` gives a vector with `TRUE` or `FALSE` for every element in `growth$well` that is equal to `"a"`.

```{r}
head(growth[growth$well == "e",])
```

Now let's perform some common mathematical operations to learn about our growth curves.

```{r}
max(growth[growth$well == "e", "od"])
```

> ## Forcing Conversion
>
> Note that R may return an error when you attempt to perform similar calculations on 
> subsetted *rows* of data frames. This is because some functions in R automatically convert 
> the object type to a numeric vector, while others do not (e.g. `max(growth[1, ])` works as 
> expected, while `mean(growth[1, ])` returns an error). You can fix this by including an 
> explicit call to `as.numeric()`, e.g. `mean(as.numeric(growth[1, ]))` (but mostly this is not what you want to do). By contrast,  calculations on subsetted *columns* always work as expected, since columns of data frames  are already defined as vectors.
{: .callout}

Particularly useful is also to user other vectors as filters and only return the rows that evaluate to `TRUE`. Here, `growth$well` 
R also has functions for other common calculations, e.g. finding the minimum, mean, and standard deviation of the data:

```{r}
min(growth[growth$well == "e", "od"])
mean(growth[growth$well == "e", "od"])
sd(growth[growth$well == "e", "od"])
```

We may want to compare the different wells and for that we can use the split-apply approach which is very common in R. A common approach is to first split the data:

```{r}
splitData <- split(growth$od, growth$well)
 ## and then apply a function
sapply(splitData, max)
 ## or in one go
tapply(growth$od, growth$well, max)
```

<img src="../fig/split-apply.svg" alt="the split apply approach, divide data to chunks, then run a given function on each ot the chunk sepearately" />

There are many more `apply` style functions among which `lapply` for applying functions to elements of lists, `apply` for applying functions to rows or columns of a matrix.

Two great packages for doing much more advanced things with data frame are `dplyr` and `tidyr` which together overlaps a lot with Python pandas but these packages are not within scope here.
